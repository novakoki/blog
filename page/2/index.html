<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Consolas</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/blog/" class="logo-link"><img src="/blog/logo.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/diary/" target="_self" class="nav-list-link">DIARY</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/tags/" target="_self" class="nav-list-link">TAGS</a></li></ul></header><section class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/DIVIDE-AND-CONQUER/" class="post-title-link">分治法</a></h2><div class="post-time">Feb 13, 2015</div><div class="post-content"><h4 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h4><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol>
<li>分割成很多个同类型的子问题(<strong>Divide</strong>)</li>
<li>递归地解决这些子问题(<strong>Conquer</strong>)</li>
<li>合并子问题的答案(<strong>Combine</strong>)</li>
</ol></div><a href="/blog/DIVIDE-AND-CONQUER/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/Choose-Good-Pivot-In-Quciksort/" class="post-title-link">在快速排序中选择好的枢纽点</a></h2><div class="post-time">Feb 13, 2015</div><div class="post-content"><p>快速排序是一个典型的分治(DIVIDE-AND-CONQUER)算法.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(array A,length n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>  <span class="keyword">return</span></span><br><span class="line">    pivot = ChoosePivot(A,n)</span><br><span class="line">    Partition A around pivot</span><br><span class="line">    Recursively sort <span class="number">1</span>st part</span><br><span class="line">    Recursively sort <span class="number">2</span>nd part</span><br></pre></td></tr></table></figure></p>
<p>而决定这个算法效率的关键就在于枢纽点(pivot)的选取，因为这直接影响到分割(partition)的好坏。最坏情况下，即每次选取的枢纽点都为最大或最小的数，则时间复杂度为 $\theta(n^2)$ .而如果能够奇迹般地每次都选择了中位数，时间复杂度就为 $\theta(n \log n)$ .以上都为理想情况的分析，而对于排序来说，效率的衡量在于比较次数。以下对各种枢纽点的选取方法做一个比较次数的测量，数据为10000个0~9999之间的整数。<br></div><a href="/blog/Choose-Good-Pivot-In-Quciksort/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/Machine-Learning-Linear-Regression/" class="post-title-link">Machine Learning : Linear Regression</a></h2><div class="post-time">Feb 7, 2015</div><div class="post-content"><p>线性回归即用线性函数对因变量和一个或多个自变量之间的关系进行建模。这个函数是多个称为回归系数的参数的线性组合。</p>
<p>给定数据集（n个变量，m组数据） </p>
<p>用矩阵来表示数据集<br>$$<br>X=<br>\begin{pmatrix}<br>1&amp;x_{11}&amp;x_{21}&amp;\cdots&amp;x_{n1}\\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>1&amp;x_{1m}&amp;x_{2m}&amp;\cdots&amp;x_{nm}<br>\end{pmatrix}<br>$$<br></div><a href="/blog/Machine-Learning-Linear-Regression/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/Machine-Learning-Introduction/" class="post-title-link">Machine Learning : Introduction</a></h2><div class="post-time">Feb 7, 2015</div><div class="post-content"><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Old</p>
<blockquote>
<p>Field of study that gives computers the ability to learn without being explicitly programmed<br> —— Arthur Samuel (1959)</p>
</blockquote>
<p>Mordern </p>
<blockquote>
<p>A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E<br>—— Tom Mitchell (1998)</p>
</blockquote></div><a href="/blog/Machine-Learning-Introduction/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/blog/Memory-Leak/" class="post-title-link">内存泄漏</a></h2><div class="post-time">Feb 4, 2015</div><div class="post-content"><blockquote>
<p>不能记住过去的人, 被迫重复过去.</p>
</blockquote>
<p>这个标题似乎表示我正准备写一篇技术文章，可惜才疏学浅（操作系统都没学在这儿BB什么！），这只是一篇偷换概念的普通随笔而已。为什么说内存泄漏呢？因为我这个人已经实实在在处于内存泄漏状态了。</p>
<p>自从大一暑假以来，以下代码描述了我的真实状态</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> learning_area T;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> (found_new_interest)&#123;</span><br><span class="line">    T* p = <span class="keyword">new</span> learning_area();<span class="comment">//同学你的指针用一次就找不到了！</span></span><br><span class="line">    p-&gt;learn_three_days();</span><br><span class="line">    p-&gt;rest_two_days();</span><br><span class="line">    <span class="comment">//同学你的delete去哪儿了？</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//同学你醒醒你醒醒</span></span><br></pre></td></tr></table></figure>
<p>然后只能睡一觉重启了<br></div><a href="/blog/Memory-Leak/" class="read-more">...more</a></article></li></ul></section><footer><div class="paginator"><a href="/blog/" class="prev">PRVE</a><a href="/blog/page/3/" class="next">NEXT</a></div><div class="copyright"><p>© 2014 - 2016 <a href="http://shaoziqi.tk/blog">Ziqi</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>