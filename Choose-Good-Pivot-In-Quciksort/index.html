<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 在快速排序中选择好的枢纽点 · Consolas</title><meta name="description" content="在快速排序中选择好的枢纽点 - Ziqi"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/blog/" class="logo-link"><img src="/blog/logo.jpg"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/diary/" target="_self" class="nav-list-link">DIARY</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/blog/tags/" target="_self" class="nav-list-link">TAGS</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">在快速排序中选择好的枢纽点</h1><div class="post-time">Feb 13, 2015</div><div class="post-content"><p>快速排序是一个典型的分治(DIVIDE-AND-CONQUER)算法.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QuickSort(array A,length n)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>  <span class="keyword">return</span></span><br><span class="line">    pivot = ChoosePivot(A,n)</span><br><span class="line">    Partition A around pivot</span><br><span class="line">    Recursively sort <span class="number">1</span>st part</span><br><span class="line">    Recursively sort <span class="number">2</span>nd part</span><br></pre></td></tr></table></figure></p>
<p>而决定这个算法效率的关键就在于枢纽点(pivot)的选取，因为这直接影响到分割(partition)的好坏。最坏情况下，即每次选取的枢纽点都为最大或最小的数，则时间复杂度为 $\theta(n^2)$ .而如果能够奇迹般地每次都选择了中位数，时间复杂度就为 $\theta(n \log n)$ .以上都为理想情况的分析，而对于排序来说，效率的衡量在于比较次数。以下对各种枢纽点的选取方法做一个比较次数的测量，数据为10000个0~9999之间的整数。<br><a id="more"></a></p>
<ol>
<li><p>选取首尾元素<br>首：162085次比较<br>尾：164123</p>
<p>这种方法的效率取决于输入数据的预排序程度，如果是已经有序的状态，则效率很低</p>
</li>
<li><p>三数中值分割法，即选择下标为第一个、最后一个、中间的三个数的中位数作枢纽点<br>138382</p>
<p>效率很高</p>
</li>
<li><p>随机选取枢纽点<br>测试了五次：<br>148958，149598，163443，161712，161399</p>
<p>随机选取枢纽点无疑是安全的，因为不可能每次都选中最坏的情形。但是另一方面，随机数的生成也耗费了时间，对实际排序的时间造成了影响。</p>
</li>
</ol>
<hr>
<p>所用的数据：<br><a href="http://spark-public.s3.amazonaws.com/algo1/programming_prob/QuickSort.txt" target="_blank" rel="external">http://spark-public.s3.amazonaws.com/algo1/programming_prob/QuickSort.txt</a><br>参考资料：<br><a href="http://www.nowamagic.net/librarys/veda/detail/2397" target="_blank" rel="external">http://www.nowamagic.net/librarys/veda/detail/2397</a></p>
<hr>
<p>参考代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pivot</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="comment">//	三数中值分割法 </span></span><br><span class="line"><span class="comment">//	int a = A[lo];</span></span><br><span class="line"><span class="comment">//	int b = A[hi];</span></span><br><span class="line"><span class="comment">//	int c = A[(lo+hi)/2];</span></span><br><span class="line"><span class="comment">//	if(( (a&gt;=b) &amp;&amp; (a&lt;=c) ) || ( (a&gt;=c) &amp;&amp; (a&lt;=b) ))</span></span><br><span class="line"><span class="comment">//		return lo;</span></span><br><span class="line"><span class="comment">//	if(((b&gt;=a)&amp;&amp;(b&lt;=c))||((b&gt;=c)&amp;&amp;(b&lt;=a)))</span></span><br><span class="line"><span class="comment">//		return hi;</span></span><br><span class="line"><span class="comment">//	if(((c&gt;=b)&amp;&amp;(c&lt;=a))||((c&gt;=a)&amp;&amp;(c&lt;=b)))</span></span><br><span class="line"><span class="comment">//		return (lo+hi)/2;</span></span><br><span class="line">	<span class="comment">//首尾 </span></span><br><span class="line">	<span class="comment">//return lo;</span></span><br><span class="line">	<span class="comment">//return hi;</span></span><br><span class="line">	<span class="comment">//随机 </span></span><br><span class="line">	<span class="comment">//srand((int)time(0));</span></span><br><span class="line">	<span class="comment">//return lo + rand()%(hi-lo);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r+<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//	for(int i = 0;i &lt; 10;i++)</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;A[i]&lt;&lt;" ";</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">	<span class="keyword">int</span> p = pivot(A,l,r);</span><br><span class="line">	<span class="comment">//cout&lt;&lt;A[p]&lt;&lt;" ";</span></span><br><span class="line">	swap(A[l],A[p]);</span><br><span class="line">	<span class="keyword">int</span> i = l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = l + <span class="number">1</span>;j &lt;= r;j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[j] &lt; A[l])&#123;</span><br><span class="line">			swap(A[j],A[i]);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(A[l],A[i<span class="number">-1</span>]);</span><br><span class="line">	QuickSort(A,l,i<span class="number">-2</span>);</span><br><span class="line">	QuickSort(A,i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div></section><footer><div class="paginator"><a href="/blog/Migration/" class="prev">上一篇</a><a href="/blog/DIVIDE-AND-CONQUER/" class="next">下一篇</a></div><div data-thread-key="Choose-Good-Pivot-In-Quciksort/" data-title="在快速排序中选择好的枢纽点" data-url="http://ziqi.moe/blog/blog/Choose-Good-Pivot-In-Quciksort/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"ziqiblog"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2014 - 2017 <a href="http://ziqi.moe/blog">Ziqi</a>, unless otherwise noted.</p></div></footer><script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>